---
title: "Lindsey Pett Final Exam PBIO 294"
output: html_notebook
---



```{r}
#1.i. likelihood function and supporting R code for finding the MLE's
#likelihood function to estimate the parameters for a quadratic regression models given in Beckage and Stout 2000 but assuming a Poisson likelihood with a log link function.
#You must write your own likelihood function and not use a built in R function or package, e.g, lm, glm, etc.
##i. *likelihood function and supporting R code for finding the MLE's*
#bring in data
srDat<-read.table("http://www.uvm.edu/~bbeckage/Teaching/PBIO_294/Data/idh.csv",sep=',',header=TRUE)
##i. *likelihood function and supporting R code for finding the MLE's*
QuadRegLik<-function(parVec,data){
  sr<-srDat$sr
  nFires<-srDat$nFires
  bo<-parVec[1]
  b1<-parVec[2]
  b2<-parVec[3]
  srPred<- bo+b1*nFires+b2*nFires^2
  lik<- -sum(dpois(round(srPred), sr, log=TRUE))
  return(lik)
}
#Set initial parameter values
parVec<-c(0,0,0)
outLM<-optim(par=parVec
             ,fn=QuadRegLik
             ,method = "SANN"
             ,data=srDat)
##ii. a *plot of the data with the fitted line*
plot(srDat$nFires, srDat$sr, xlab="Number of Fires", ylab="Species Richness")
PredictedRichness1 <-outLM$par[1]+outLM$par[2]*srDat$nFires+outLM$par[3]*srDat$nFires^2
lines(srDat$nFires, PredictedRichness1, col="blue", lwd=2, lty=2)
lines(c(.2, 1.8), c(32.5, 32.5), lty=2, lwd=2, col="blue")
text(2.8, 32.5, labels="Fitted Line")
##iii. report the *regression parameters (bo, b1, and b2)*
outLM$par
##iv. the value of the *negative log likelihood at the MLEs*
outLM$value
```

```{r}
# Repeat exercise 1 except now fitting the model using either Rstan or Tjags.
#2.i. Stan/JAGS model code and supportin R code for running the Stan/JAGS model
srDat<-read.table("http://www.uvm.edu/~bbeckage/Teaching/PBIO_294/Data/idh.csv",sep=',',header=TRUE)
srDat$nFires2<-(srDat$nFires)^2
code <- '
data {
    int<lower=0> N;                  
    vector[N] sr;              
    vector[N] nFires;              
    vector[N] nFires2;            
}
parameters {
    real b0;                 
    real b1 ;                 
    real b2;                  
    real<lower=0> sigma;      
}
model {
    b0 ~ normal(6,100);          
    b1 ~ normal(6,100);      
    b2 ~ normal(0,100);    
    sigma ~ normal(0, 100);    
    sr ~ normal(b0 + b1 * nFires + b2 * nFires2, sigma);
}
'

# Prepare data list
data.list <- list(N = nrow(srDat), sr = srDat$sr, nFires = srDat$nFires,
                  nFires2 = srDat$nFires2)
str(data.list)

library(rstan)
# Estimate model
model <- stan(model_code = code, data = data.list, iter = 1000, chains = 5)
model1<-extract(model)
print(model, digits = 2)

plot(srDat$nFires, srDat$sr, xlab="Number of Fires", ylab="Species Richness")
PredictedRichness1 <-mean(model1$b0)+mean(model1$b1)*srDat$nFires+mean(model1$b2)*srDat$nFires2
lines(srDat$nFires, PredictedRichness1, col="red", lwd=2, lty=2)
lines(c(2.5, 4.1), c(5, 5), lty=2, lwd=2, col="red")
text(6, 5, labels="Fitted Line - Bayes")


#2.ii report teh 2.5%,50%, and 97.5% percentiles for the regression parameters (b0,b1, and b2)
		#bo 2.5% = 4.57, 50% = 6.22, 97.5% = 8.00
    #b1 2.5% = 5.59, 50% = 6.36, 97.5% = 7.00
    #b2 2.5% = -0.70, 50% = -0.64, 97.5% = -0.58

#2.iii plot the posteriror distributions for each of theses parameters
par(mfrow=c(2,2))
##bo posterior
plot(density(model1$b0), main = "b0")  # draw posterior
##b1 posterior
plot(density(model1$b1), main = "b1")  # draw posterior
##b2 posterior
plot(density(model1$b2), main = "b2")  # draw posterior


#2.iv asses the convergence of your chains using the Gelman-Rubin statistic.
library(coda)
stan2coda <- function(model1) {
        mcmc.list(lapply(1:ncol(model1), function(x) mcmc(as.array(model1)[,x,])))
}
fit.mcmc <- stan2coda(model)

model.gelm<-gelman.diag(fit.mcmc)
model.gelm$mpsrf
#mpsrf near zeroes means good convergence. 
```

```{r}
# Read in data
seeds<-read.table("http://www.uvm.edu/~bbeckage/Teaching/PBIO_294/Data/seeds.csv",sep=',',header=TRUE)
#Seed lost ~ Binomial(theta) # 1 if seed is predated, 0 if seed is left alone
#Logit(theta) = b0i + b1 x gap 
#b0i ~ gamma(mu^2/sd^2,mu/sd^2) 
#mui = b2 + b3 x seed mass i - b4 x (seed mass i)^2 
#sd^2 ~ gamma(0.001,0.001)
#b1,b2,b3,b4 ~ normal(0,100)
#i. *Stan/JAGS model code and supporting R code for running the Stan/JAGS model*,
library(rstan)
seeds.list<-list(N=nrow(seeds), gap=seeds$gap, mass=seeds$mass, seedLost=seeds$seedLost)
modelString <- "
data {
int<lower=0> N ; 
real <lower=0> gap[N] ; 
real <lower=0> mass[N]; 
int <lower=0> seedLost[N]; 
}
parameters {
real b1;  
real b2; 
real b3;
real b4;
real <lower=0> sigma;
real <lower=0> b0[N];
}
transformed parameters{
real <lower=0> p[N]; 
real <lower=0> m[N]; 
for (i in 1:N){
p[i]<-inv_logit(b0[i]+b1*gap[i]);
m[i]<-b2+b3*mass[i]-b4*pow(mass[i],2);
}
}
model {
	sigma~inv_gamma(.001,.001);
	b1~normal(0,100);
	b2~normal(0,100);
	b3~normal(0,100);
	b4~normal(0,100);
	for(i in 1:N){
b0[i]~gamma(pow(m[i],2)/pow(sigma,2), m[i]/pow(sigma,2));
seedLost[i]~binomial(1, p[i]) ;
}
}
" 
help(stan)
library(coda)
model <- stan(model_code = modelString, data = seeds.list, iter = 100, chains = 2, control=list(adapt_delta=0.9))
model1<-extract(model)


#3.ii report the 2.5%, 50%, and 97% percentiles for the regression parameters (b0, b1, b2, b3, b4)
		#bo 2.5% = 0.0003059913 , 50% = 0.7690219, 97.5% = 3.281064
quantile(model1$b0,probs=c(.025)); quantile(model1$b0,probs=c(.50)); quantile(model1$b0,probs=c(.97))
    #b1 2.5% = 1.660424 , 50% = 2.145865, 97.5% = 2.675786
quantile(model1$b1,probs=c(.025)); quantile(model1$b1,probs=c(.50)); quantile(model1$b1,probs=c(.97))
    #b2 2.5% = 0.1127688, 50% = 0.7139886, 97.5% = 1.344343
quantile(model1$b2,probs=c(.025)); quantile(model1$b2,probs=c(.50)); quantile(model1$b2,probs=c(.97))
    #b3 2.5% = -0.2794495 , 50% = 0.7139886, 97.5% = 0.1620858
quantile(model1$b3,probs=c(.025)); quantile(model1$b2,probs=c(.50)); quantile(model1$b3,probs=c(.97))
    #b4 2.5% = -0.04764915 , 50% = 0.7139886, 97.5% = 0.01188538
quantile(model1$b4,probs=c(.025)); quantile(model1$b2,probs=c(.50)); quantile(model1$b4,probs=c(.97))

#3.iii plot the posterior distributions for each of these parameters
par(mfrow=c(3,2))
##bo posterior
plot(density(model1$b0), main = "b0")  # draw posterior
##b1 posterior
plot(density(model1$b1), main = "b1")  # draw posterior
##b2 posterior
plot(density(model1$b2), main = "b2")  # draw posterior
##b3 posterior
plot(density(model1$b3), main = "b3")  # draw posterior
##b4 posterior
plot(density(model1$b4), main = "b4")  # draw posterior

#3.iv assess the convergence of your chains using the Gelman-Rubin statistic
stan2coda <- function(model1) {
        mcmc.list(lapply(1:ncol(model1), function(x) mcmc(as.array(model1)[,x,])))
}
fit.mcmc1 <- stan2coda(model)
##Was unable to get the gelman rubin statistic to run. I could get line 200 to run if multivarite = false but then the next line would not work and get the error null.  Worked on this part for a solid day and just could not crack the code
model.gelm<-gelman.diag(fit.mcmc1,multivariate=TRUE)
model.gelm$mpsrf



```

