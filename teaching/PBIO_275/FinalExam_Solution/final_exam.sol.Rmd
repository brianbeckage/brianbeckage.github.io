---
title: "R Notebook"
output: Final Exam
---


1. (30 points) An ecologist is interested in the intermediate disturbance hypothesis (IDH) 
that postulates that the highest species richness should be found at intermediate levels of 
disturbance. Write a  likelihood function to estimate the  
parameters for a quadratic regression models given in Beckage and Stout 2000 
(http://www.uvm.edu/~bbeckage/Manuscripts/BeckageStout.corrected.2000.jvs.pdf), 
but assuming a Poisson likelihood with a log link function.  Provide your i. *likelihood function and supporting R code for finding the MLE's*, ii. a *plot of the data with the fitted line* and iii. report the *regression parameters (bo, b1, and b2)*, and iv. the value of the *negative log likelihood at the MLEs*.

The data can be read using:
```{r}
srDat<-read.table("http://www.uvm.edu/~bbeckage/Teaching/PBIO_294/Data/idh.csv",sep=',',header=TRUE)
plot(srDat$nFires,srDat$sr)
```


The code below was used to generate the data read in above:
```{r}
nFires<-seq(from=1,to=10,by=1)
b0<-5
b1<-7
b2<-0.7
lambdaVect<-b0+b1*nFires-b2*nFires^2
srVect<-mapply(rpois,rep(30,length(lambdaVect)), lambdaVect)
srVect<-as.vector(srVect)
nFires<-mapply(rep,nFires,30)
nFires<-as.vector(nFires)
srDat<-data.frame(srVect,nFires)
colnames(srDat)<-c('sr','nFires')
plot(srDat$nFires,srDat$sr)

setwd("~/Documents/Web/Teaching/PBIO_294/FinalExam")
write.table(srDat,file="idh.csv",sep=',')
myDat<-read.table("idh.csv",sep=',',header=T)
```



```{r}
nllPoi<-function(parVec,myDat){
  nBurns<-myDat$nFires
  nSpecies<-myDat$sr
  b0<-parVec[1]
  b1<-parVec[2]
  b2<-parVec[3]
  
  nSpeciesPred<-exp(b0+b1*nBurns+b2*nBurns^2)
  nllik<- -sum(dpois(x=nSpecies,lambda=nSpeciesPred,log=TRUE))
  #nllik<- -(sum( (dbinom(x=nSurvive, size=nPlanted, prob=pSurv,log=TRUE)) ,na.rm=T))
  #browser()
  cat("nllik= ",nllik,sep=" ",fill=T) #;cat(" ",sep=" ",fill=T)
  return(nllik)
}
```

```{r}
parVec<-c(0.5,0.1,-0.4) # Initial parameter values 
outNull<-optim(par=parVec,fn=nllPoi,method="L-BFGS-B",lower=c(-Inf,-Inf,-Inf),upper=c(Inf,Inf,Inf),
               myDat=srDat)
outNull$par # 2.05526766  0.44431096 -0.04587891
outNull$val # nllik= 848.023


# Plotting fit
b0<-outNull$par[1];b1<-outNull$par[2];b2<-outNull$par[3]
nBurns<-seq(from=1,to=10,by=1)
nSpeciesPred<-exp(b0+b1*nBurns+b2*nBurns^2)
plot(srDat$nFires,srDat$sr)
lines(nBurns,nSpeciesPred)


myAIC<-2*2 + 2*outNull$val 
myAIC

```

2. (30 points) Repeat exercise 1 except now fitting the model using either Rstan or Rjags.  You must write your own Stan/JAGS model, meaning that you can not use one of the Stan helper libraries such as the brms or rstanarm libraries. Provide your i. *Stan/JAGS model code and supporting R code for running the Stan/JAGS model*, ii. report the *2.5%, 50%, and 97.5% percentiles for the regression parameters (bo, b1, and b2)*, iii. *plot the posterior distributions for each of these parameters* and iv. *assess the convergence of your chains using the Gelman-Rubin statistic.* 

```{r}
setwd("~/Documents/Web/Teaching/PBIO_294/FinalExam_Solution")
getwd()
```

```{r}
srDat<-read.table("http://www.uvm.edu/~bbeckage/Teaching/PBIO_294/Data/idh.csv",sep=',',header=TRUE)
plot(srDat$nFires,srDat$sr)
```

** JAGS solution for Problem 2**

```{r}
library(rjags)
jags <- jags.model('poissonReg.jags.txt',
                   data = list('nSpecies' = srDat$sr,
                               'nBurns' = srDat$nFires,
                               'N' = length(srDat$nFires)),
                   inits<-list(
                       list('beta0'=0.05,'beta1'=1.2,'beta2'= -0.5),
                       list('beta0'=0.01,'beta1'=0.2,'beta2'= -0.2),
                       list('beta0'=.1,'beta1'=0.02,'beta2'= -0.02),
                       list('beta0'=0.2,'beta1'=0.5,'beta2'= -0.002)),
                   n.chains = 4,
                   n.adapt = 100)
```


```{r}
library(coda)
update(jags, 1000)
codaSamples<-coda.samples(jags, c('beta0','beta1','beta2'), 10000, 1)
```
```{r}
plot(codaSamples, trace = FALSE, density = TRUE)
summary(codaSamples)
traceplot(codaSamples)
```

# The gelman.diag gives you the scale reduction factors for eachparameter. A factor of 1 means that between chain variance and within chain variance are equal, larger values mean that there is still a notable difference between chains. A rule of thumb is that values of 1.1 and less suggests adequate convergence.

```{r}
plot(codaSamples, trace = FALSE, density = TRUE)
gelman.diag(codaSamples, confidence=.95)
gelman.plot(codaSamples, confidence=.95)

```


```{r}
modelString<-"
model {
  for (i in 1:N){
    nSpecies[i] ~ dpois(lam.hat[i])
    log(lam.hat[i]) <- beta0 + beta1 * nBurns[i] + beta2 * (nBurns[i])^2
  }
  beta0 ~ dnorm(0, .0001)
  beta1 ~ dnorm(0, .0001)
  beta2 ~ dnorm(0, .0001)
}
"
writeLines(modelString, con='poissonReg.jags.txt')
```


```{r}
gelman.diag(codaSamples, confidence=.95)
```


** Stan solution for Problem 2**

```{r}
modelString<-"data {
  int<lower=0> N;
  int<lower=0> nBurns[N];
  int<lower=0> nSpecies[N];
}

parameters {
  real beta0;
  real beta1;
  real beta2;
}

transformed parameters {
  real lp[N];
  real <lower=0> mu[N];
  
  for(i in 1:N){
    lp[i] = beta0 + beta1 * nBurns[i] + beta2 * (nBurns[i])^2;
    mu[i] = exp(lp[i]);
  }
}

model {
  nSpecies ~ poisson(mu);
}"

```



```{r}
library(rstan)

myData<- list(nSpecies= srDat$sr,nBurns = srDat$nFires, N = length(srDat$nFires))

resStan <- stan(model_code = modelString, data = myData,
                chains = 3, iter = 3000, warmup = 500, thin = 10)
summary(resStan,par=c('beta0','beta1','beta2'))
model1<-extract(resStan)
print(model, digits = 2)
plot(density(model1$b0), main = "b0") 

# myData<-list(nSeedlings=nSeedlings,light=light,N=length(light))
# resStan <- stan(model_code = 'poissonReg.stan', data = myData,
#                chains = 3, iter = 3000, warmup = 500, thin = 10)
```


```{r}
library(coda)
post_fit<-As.mcmc.list(resStan) 
plot(post_fit,par=c('beta0','beta1'))
```







3. (40 points) An ecologist expects seed predation to be influenced by the presence of openings (gaps) in the forest overstory and seed mass. The effect of seed mass on predation is expected be quadratic:  Small seeds will be less predated because they offer a lower energetic reward while larger seeds will be too difficult to process, so that medium sized seeds will be most predated.  The effect of a gap is additive with lower predation expected in gaps because seed predators avoid areas of open canopy. The ecologist models the data as a hierarchical logistic regression, assuming that the seed masses are known without observation error.  The model has the form:

Seed lost ~ Binomial(theta) # 1 if seed is predated, 0 if seed is left alone
Logit(theta) = b0i + b1 x gap 
b0i ~ gamma(mu^2/sd^2,mu/sd^2) 
mui = b2 + b3 x seed mass i - b4 x (seed mass i)^2 
sd^2 ~ gamma(0.001,0.001)
b1,b2,b3,b4 ~ normal(0,100)

Fit this model using either Rstan or Rjags.  You must write your own Stan/JAGS model, meaning that you can not use one of the Stan helper libraries such as the brms or rstanarm libraries. Provide your i. *Stan/JAGS model code and supporting R code for running the Stan/JAGS model*, ii. report the *2.5%, 50%, and 97.5% percentiles for the regression parameters (b1, b1, b2, b3, and b4)*, iii. *plot the posterior distributions for each of these parameters* and iv. *assess the convergence of your chains using the Gelman-Rubin statistic.*

```{r}
nSamples<-1000
b1<-2; b2<-0.1; b3<-0.05; b4<- -0.01
mass<-runif(nSamples,min=1,max=10)
mu<-b2+b3*mass-b4*mass^2
sigma<-0.1

b0<-mapply(rgamma,1,shape=mu^2/sigma^2,rate=mu/sigma^2)
gap<-c(rep(1,500),rep(0,500))
p<-exp(b0+b1*gap)/(exp(b0+b1*gap)+1)
seedLost<-as.vector(mapply(rbinom,1,rep(1,1000),p))
plot(jitter(gap),jitter(seedLost))

seeds<-data.frame(seedLost,mass,gap)
#colnames(seeds)<-c('height','soil','light')
write.table(seeds,file="seeds.csv",sep=',')
myDat<-read.table("seeds.csv",sep=',',header=T)
```

The data can be read using:
```{r}
seeds<-read.table("http://www.uvm.edu/~bbeckage/Teaching/PBIO_294/Data/seeds.csv",sep=',',header=TRUE)
head(seeds)
```


** JAGS solution for Problem 3**
Solution 1: without log link for mu: PROBABLY NOT BEST SOLUTIONS

```{r}
library(rjags)
jags <- jags.model('seedPredation.jags.txt',
                   data = list('seedLost' = seeds$seedLost,
                               'sdMass' = seeds$mass,
                               'gap' = seeds$gap,
                               'N' = length(seeds$mass)),
                   inits<-list(
                       list('beta1'=1.2,'beta2'= -0.5,'beta3'= 0.5,'beta4'= 0.05),
                       list('beta1'=0.2,'beta2'= 0.2,'beta3'= 0.15,'beta4'= 0.15),
                       list('beta1'=0.02,'beta2'= 0.02,'beta3'= 0.005,'beta4'= 0.005),
                       list('beta1'=0.5,'beta2'= 1.2,'beta3'= 0.05,'beta4'= 0.015)),
                   n.chains = 4,
                   n.adapt = 100)
```

```{r}
modelString<-"
model {
  for (i in 1:N){
    seedLost[i] ~ dbern(theta[i])
    logit(theta[i]) <- beta0[i] + beta1 * gap[i]
    beta0[i]~dgamma(a[i],b[i])
    a[i]<-mu[i]^2/varG
    b[i]<-mu[i]/varG
    mu[i]<-beta2 + beta3*sdMass[i] + beta4*(sdMass[i]^2)
    #   log(mu[i])<-beta2 + beta3*sdMass[i] + beta4*(sdMass[i]^2)
  }
  varG ~  dgamma(0.001,0.001)
  beta1 ~ dnorm(0, .0001)
  beta2 ~ dnorm(0, .0001)
  beta3 ~ dnorm(0, .0001)
  beta4 ~ dnorm(0, .0001)
}
"

writeLines(modelString, con='seedPredation.jags.txt')
```

Seed lost ~ Binomial(theta) # 1 if seed is predated, 0 if seed is left alone
Logit(theta) = b0i + b1 x gap 
b0i ~ gamma(mu^2/sd^2,mu/sd^2) 
mui = b2 + b3 x seed mass i - b4 x (seed mass i)^2 
sd^2 ~ gamma(0.001,0.001)
b1,b2,b3,b4 ~ normal(0,100)

```{r}
library(coda)
update(jags, 1000)
codaSamples<-coda.samples(jags, c('beta1','beta2','beta3','beta4','varG'), 10000, 10)
```

```{r}
plot(codaSamples, trace = FALSE, density = TRUE)
summary(codaSamples)
traceplot(codaSamples)
```


** JAGS solution for Problem 3**
Solution 1: with log link for mu: PROBABLY BEST MODEL FOR THE DATA


```{r}
jags <- jags.model('seedPredation.jags.txt',
                   data = list('seedLost' = seeds$seedLost,
                               'sdMass' = seeds$mass,
                               'gap' = seeds$gap,
                               'N' = length(seeds$mass)),
                  # inits<-list(list('beta1'=1.2,'beta2'= 0.05,'beta3'= 0.5,'beta4'= 0.05)),
                   n.chains = 1,
                   n.adapt = 100)
```

```{r}
library(coda)
update(jags, 1000)
codaSamples<-coda.samples(jags, c('beta1','beta2','beta3','beta4','varG'), 10000, 10)
```


```{r}
plot(codaSamples, trace = FALSE, density = TRUE)
summary(codaSamples)
traceplot(codaSamples)
```



```{r}
modelString<-"
model {
  for (i in 1:N){
    seedLost[i] ~ dbern(theta[i])
    logit(theta[i]) <- beta0[i] + beta1 * gap[i]
    beta0[i]~dgamma(a[i],b[i])
    a[i]<-mu[i]^2/varG
    b[i]<-mu[i]/varG
    log(mu[i])<-beta2 + beta3*sdMass[i] + beta4*(sdMass[i]^2)
    #   log(mu[i])<-beta2 + beta3*sdMass[i] + beta4*(sdMass[i]^2)
  }
  varG ~  dgamma(0.001,0.001)
  beta1 ~ dnorm(0, .0001)
  beta2 ~ dnorm(0, .0001)
  beta3 ~ dnorm(0, .0001)
  beta4 ~ dnorm(0, .0001)
}
"

writeLines(modelString, con='seedPredation.jags.txt')
```

Seed lost ~ Binomial(theta) # 1 if seed is predated, 0 if seed is left alone
Logit(theta) = b0i + b1 x gap 
b0i ~ gamma(mu^2/sd^2,mu/sd^2) 
# mui = b2 + b3 x seed mass i - b4 x (seed mass i)^2 
log(mui)<-b2 + b3 x seed mass i - b4 x (seed mass i)^2 
sd^2 ~ gamma(0.001,0.001)
b1,b2,b3,b4 ~ normal(0,100)



** Stan solution for Problem 3**

```{r}
modelString<-"
data {
  int <lower=1> N;
  real <lower=0> sdMass[N];
  int <lower=0, upper=1> seedLost[N];
  int <lower=0, upper=1> gap[N];
}

parameters {
  real <lower=0> beta0[N]; //?
  real beta1;
  real beta2;
  real beta3;
  real beta4;
  real<lower=0> sigG;
}

transformed parameters {
  real<lower=0> mu[N];
  real <lower=0> p[N];
  real lmu[N];
  //real a[N];
  //real b[N];
  real<lower=0,upper=1> theta[N];
  
  for(i in 1:N){
    lmu[i] = beta2 + beta3*sdMass[i] + beta4*(sdMass[i]^2);
    mu[i] = exp(lmu[i]);
    //a[i] = pow(mu[i],2)/pow(sigG,2); 
    //b[i] = mu[i]/pow(sigG,2);  
    p[i]=exp(beta0[i]+beta1*gap[i]);
    theta[i]=p[i]/(1+p[i]);
  }
}


model {
  for(i in 1:N){
    beta0[i] ~ gamma(pow(mu[i],2)/pow(sigG,2), mu[i]/pow(sigG,2)); //gamma(a[i],b[i]);
    seedLost[i] ~ bernoulli(theta[i]);
  }
  sigG ~ inv_gamma(0.001,0.001); 
  beta1~normal(0,100);
  beta2~normal(0,100);
  beta3~normal(0,100);
  beta4~normal(0,100);

}"


```
  


```{r}
library(rstan)
myData<-list(seedLost=seeds$seedLost,sdMass=seeds$mass,
             gap=seeds$gap,N=length(seeds$seedLost))

# resStan <- stan(model_code = 'poissonReg.stan', data = myData,
#                chains = 3, iter = 3000, warmup = 500, thin = 10)

resStan <- stan(model_code = modelString, data = myData,
                chains = 3, iter = 3000, warmup = 500, thin = 2)

summary(resStan,par=c('beta1','beta2','beta3','beta4','sigG'))

library(coda)
post_fit<-As.mcmc.list(resStan) 
summary(post_fit,par=c('beta1','beta2','beta3','beta4','sigG'))
plot(post_fit,par=c('beta1','beta2','beta3','beta4','sigG'))

```




Marina's code

```{r}
library(rstan)
myData<-list(seeds=seeds$seedLost,mass=seeds$mass,
             gap=seeds$gap,N=length(seeds$seedLost))

# resStan <- stan(model_code = 'poissonReg.stan', data = myData,
#                chains = 3, iter = 3000, warmup = 500, thin = 10)

resStan <- stan(model_code = modelString, data = myData,
                chains = 3, iter = 10000, warmup = 500, thin = 2)

summary(resStan,par=c('b1','b2','b3','b4','sdGamma'))
```





```{r}
modelString <- "
// marina's code modified by myself
data {
int <lower=1> N; 
int <lower=0> seeds[N]; 
real <lower=0> mass[N]; 
int <lower=0, upper=1> gap[N];
}

parameters {
real b1;
real b2;
real b3;
real b4;
real <lower=0> sdGamma;
real <lower=0> b0[N];
}

transformed parameters{
real <lower=0> mu[N]; 
real <lower=0> lmu[N]; 
real <lower=0> p[N];
real <lower=0,upper=1> prob[N];


for (i in 1:N){
lmu[i]=b2+b3*mass[i]-b4*pow(mass[i],2);
mu[i]=exp(lmu[i]);
p[i]=exp(b0[i]+b1*gap[i]);
prob[i]=p[i]/(1+p[i]);
}
}

model {
for(i in 1:N){
b0[i]~gamma(pow(mu[i],2)/pow(sdGamma,2), mu[i]/pow(sdGamma,2));
seeds[i]~bernoulli(prob[i]);
}

// priors
sdGamma~inv_gamma(.001,.001); 
b1~normal(0,100);
b2~normal(0,100);
b3~normal(0,100);
b4~normal(0,100);
}
" 
```


